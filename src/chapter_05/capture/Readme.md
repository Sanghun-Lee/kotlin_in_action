## 5.1.4 현재 영역에 있는 변수에 접근

> 자바의 경우, 익명 내부 클래스에서 해당 클래스 외부의 변수에 접근 가능하다.
> 모든 변수에 접근가능한것은 아니고, `final`로 정의된 변수만 접근 가능하다.
> 
> 하지만, 코틀린의 경우, 모든 타입의 변수에 접근 가능하고, 수정도 가능한데 어떻게 그게 가능한지 살펴보자.

[lambdaAccess.kt](lambdaAccess.kt) 파일을 살펴보면, forEach 람다식 내부에서 파라미터인 prefix에 접근 가능하다.

이런 기능은 자바에서도 지원하지만, 더 중요한 기능은, `final` 변수가 아닌, 일반 변수도 접근 가능하고 값을 변경할 수 있다.

### 람다의 capture

람다 내에서 외부 변수를 사용하는 경우, 그 변수를 **람다가 포획(capture)한 변수** 라고 한다.

기본적으로 함수 내 변수의 생명주기는 함수가 끝나면 끝이지만, 람다가 포획한 변수는 생명주기가 달라질 수 있다.

final 변수의 경우, 람다를 구성할 때 값을 복사하고

그 외 변수의 경우 Wrapper한 후 Wrapper에 대한 참조를 람다 코드와 같이 정의한다.

#### 자세한 구현방법

그 외 변수를 람다에 저장할때에는 **원소가 1개인 배열**을 선언하거나 **해당 변수를 필드로 갖는 클래스**를 생성한다.

```kotlin
// Wrapper 클래스를 만드는 경우
// clientCounter를 보면..
class Ref<T>(var value: T)

val counter = Ref(0)
val inc = { counter.value++ }
```

`Ref` 함수를 만들고, counter에게 0 값을 대입한다.

counter 변수의 경우, val로 정의되어있으니, fianl 변수이고, 람다를 구성할 때 이런 counter 변수값을 넘겨줌으로써 람다 내부에서 모든 타입의 변수를 사용할 수 있다.

실제로 유저가 사용할때는 그냥 var 변수에 접근하는것이지만, 내부적으로 Wrapper를 통해 이런 자바 정책을 우회할 수 있다.